# Download and configure kubeconfig for local use
- name: Fetch kubeconfig from first server
  ansible.builtin.fetch:
    src: /home/{{ ansible_user }}/.kube/config
    dest: "{{ playbook_dir }}/../../kubeconfig"
    flat: true
  when: inventory_hostname == groups['servers'][0]

- name: Read the fetched kubeconfig
  ansible.builtin.slurp:
    src: "{{ playbook_dir }}/../../kubeconfig"
  register: kubeconfig_content
  delegate_to: localhost
  when: inventory_hostname == groups['servers'][0]
  run_once: true

- name: Parse kubeconfig content
  ansible.builtin.set_fact:
    kubeconfig_yaml: "{{ kubeconfig_content.content | b64decode | from_yaml }}"
  when: inventory_hostname == groups['servers'][0]
  run_once: true

- name: Create cluster name
  ansible.builtin.set_fact:
    cluster_name: "rke2-{{ vip | replace('.', '-') }}"
  when: inventory_hostname == groups['servers'][0]
  run_once: true

- name: Update kubeconfig with VIP and proper cluster naming
  ansible.builtin.set_fact:
    updated_kubeconfig:
      apiVersion: "{{ kubeconfig_yaml.apiVersion }}"
      kind: "{{ kubeconfig_yaml.kind }}"
      clusters:
        - name: "{{ cluster_name }}"
          cluster:
            certificate-authority-data: "{{ kubeconfig_yaml.clusters[0].cluster['certificate-authority-data'] }}"
            server: "https://{{ vip }}:6443"
      contexts:
        - name: "{{ cluster_name }}"
          context:
            cluster: "{{ cluster_name }}"
            user: "{{ cluster_name }}-admin"
      current-context: "{{ cluster_name }}"
      users:
        - name: "{{ cluster_name }}-admin"
          user:
            client-certificate-data: "{{ kubeconfig_yaml.users[0].user['client-certificate-data'] }}"
            client-key-data: "{{ kubeconfig_yaml.users[0].user['client-key-data'] }}"
  when: inventory_hostname == groups['servers'][0]
  run_once: true

# Create kubeconfig backup with timestamp
- name: Write updated kubeconfig to project directory
  ansible.builtin.copy:
    content: "{{ updated_kubeconfig | to_nice_yaml(indent=2) }}"
    dest: "{{ playbook_dir }}/../../kubeconfig"
    mode: '0600'
  delegate_to: localhost
  when: inventory_hostname == groups['servers'][0]
  run_once: true

- name: Create timestamped kubeconfig backup
  ansible.builtin.copy:
    src: "{{ playbook_dir }}/../../kubeconfig"
    dest: "{{ playbook_dir }}/../../kubeconfig-{{ ansible_date_time.epoch }}"
  delegate_to: localhost
  when: inventory_hostname == groups['servers'][0]
  run_once: true

# Optionally merge with local kubeconfig
- name: Check if local kubeconfig exists
  ansible.builtin.stat:
    path: "{{ lookup('env', 'HOME') }}/.kube/config"
  register: local_kubeconfig
  delegate_to: localhost
  when: inventory_hostname == groups['servers'][0]
  run_once: true

- name: Create local .kube directory if it doesn't exist
  ansible.builtin.file:
    path: "{{ lookup('env', 'HOME') }}/.kube"
    state: directory
    mode: '0755'
  delegate_to: localhost
  when: inventory_hostname == groups['servers'][0]
  run_once: true

- name: Backup existing local kubeconfig
  ansible.builtin.copy:
    src: "{{ lookup('env', 'HOME') }}/.kube/config"
    dest: "{{ lookup('env', 'HOME') }}/.kube/config.backup-{{ ansible_date_time.epoch }}"
  delegate_to: localhost
  when:
    - inventory_hostname == groups['servers'][0]
    - local_kubeconfig.stat.exists
  run_once: true

- name: Copy kubeconfig to local .kube directory
  ansible.builtin.copy:
    src: "{{ playbook_dir }}/../../kubeconfig"
    dest: "{{ lookup('env', 'HOME') }}/.kube/config"
    mode: '0600'
  delegate_to: localhost
  when: inventory_hostname == groups['servers'][0]
  run_once: true

# Merge with existing kubeconfig if available
- name: Check if kubectl is available
  ansible.builtin.command: which kubectl
  register: kubectl_check
  delegate_to: localhost
  ignore_errors: true
  when: inventory_hostname == groups['servers'][0]
  run_once: true

- name: Merge kubeconfig contexts if kubectl is available
  ansible.builtin.shell: |
    # Create a separate context file
    cp "{{ playbook_dir }}/../../kubeconfig" "{{ lookup('env', 'HOME') }}/.kube/config-{{ cluster_name }}"

    # If there's an existing config and kubectl is available, merge contexts
    if [ -f "{{ lookup('env', 'HOME') }}/.kube/config.backup-{{ ansible_date_time.epoch }}" ] && command -v kubectl > /dev/null; then
      KUBECONFIG="{{ lookup('env', 'HOME') }}/.kube/config.backup-{{ ansible_date_time.epoch }}:{{ lookup('env', 'HOME') }}/.kube/config-{{ cluster_name }}" kubectl config view --flatten > /tmp/merged-kubeconfig
      mv /tmp/merged-kubeconfig "{{ lookup('env', 'HOME') }}/.kube/config"
      chmod 600 "{{ lookup('env', 'HOME') }}/.kube/config"
      kubectl config use-context "{{ cluster_name }}"
    else
      # If no existing config or kubectl not available, just use the new one
      cp "{{ lookup('env', 'HOME') }}/.kube/config-{{ cluster_name }}" "{{ lookup('env', 'HOME') }}/.kube/config"
    fi
  delegate_to: localhost
  when:
    - inventory_hostname == groups['servers'][0]
    - local_kubeconfig.stat.exists
  run_once: true

- name: Display kubeconfig information
  ansible.builtin.debug:
    msg:
      - "=== Kubeconfig Management ==="
      - "Cluster name: {{ cluster_name }}"
      - "Cluster kubeconfig downloaded to: {{ playbook_dir }}/../../kubeconfig"
      - "Local kubeconfig updated: {{ lookup('env', 'HOME') }}/.kube/config"
      - "Context-specific config: {{ lookup('env', 'HOME') }}/.kube/config-{{ cluster_name }}"
      - "Cluster endpoint: https://{{ vip }}:6443"
      - ""
      - "Test cluster access with:"
      - "kubectl get nodes"
      - "kubectl cluster-info"
      - ""
      - "Switch contexts with:"
      - "kubectl config use-context {{ cluster_name }}"
  when: inventory_hostname == groups['servers'][0]
  run_once: true
